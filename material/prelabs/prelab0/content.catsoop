After completing an exercise, feel free to click View Answer > View Explanation to see the key takeaways.

<catsoop-section>Conditional Statements</catsoop-section>

Say we declare the following variables:

```py
a = True
b = 5
c = 7
```

<question multiplechoice>
csq_renderer = "checkbox"
csq_prompt = """
If we were to then run the following code, what would be printed? (Choose all the apply.)
```py
if not a:
    print('X')
elif b > c:
    print('Y')
else:
    print('Z')
```
"""

csq_options = ['X', 'Y', 'Z']
csq_soln = [False, False, True]

csq_explanation = """`not a` evaluates to `False` since `a = True`. 
`b > c` evaluates to `False` because `b=5` is not greater than `c=7`. 
Therefore, the conditional statement defaults to the `else` branch which prints `Z`.

[KEY IDEAS]
`not` flips the value of a Boolean expression.
"""
</question>

<question multiplechoice>
csq_renderer = "checkbox"
csq_prompt = """
If we were to then run the following code, what would be printed? (Choose all the apply.)
```py
if a or b > c:
    print('X')
elif b == 5:
    print('Y')
else:
    print('Z')
```
"""

csq_options = ['X', 'Y', 'Z']
csq_soln = [True, False, False]

csq_explanation = """
`a` is `True`. 
Even though `b > c` evaluates to `False`, the `or` condition only requires one of the Boolean expressions to evaluate to `True`. 
A conditional statement only branches into the first branch that evaluates to `True` (or the `else` branch if all else fail).
Even though `b == 5` would evaluate to `True`, that branch is never even checked/considered because the first branch was taken.

[KEY IDEAS] 
`or` only requires one of its two expressions to be `True`.
Only the first branch of the first expression to be `True` is taken.
"""
</question>

<question multiplechoice>
csq_renderer = "checkbox"
csq_prompt = """
If we were to then run the following code, what would be printed? (Choose all the apply.)
```py
if a and c == 7:
    print('X')
    if b == c:
        print('Y')
    else:
        print('Z')
    print('A')
if b != c:
    print('B')
```
"""

csq_options = ['X', 'Y', 'Z', 'A', 'B']
csq_soln = [True, False, True, True, True]

csq_explanation = """
`a` is `True` and `c==7` is `True`. `and` requires both of the Boolean expressions to be `True`, so the `if` branch is taken.
The code then moves on to a nested conditional statement (#2). 
(It's called a nested conditional statement because it is a conditional statement within a conditional statement.)
The first branch checks if `b == c` which is `False`, so the `else` branch is executed.
After this nested conditional statement is exited, we continue with conditional statement #1, which prints `A`.
Lastly, another conditional statement (#3) is checked.
This one checks if `b != c`, which is `True`, so the `if` branch is taken.

```py
if a and c == 7: # start of conditional 1
    print('X')
    if b == c: # start of conditional 2
        print('Y')
    else:
        print('Z') # end of conditional 2
    print('A') # end of conditional 1
if b != c: # start of conditional 3
    print('B') # end of conditional 3
```

[KEY IDEAS]
An `if` statement denotes the start of a new, independent conditional statement. 
An (optional) `else` statement denotes the end of a conditional statement.
A conditional statement may itself contain as many other conditional statements as we want.
Indentation tells us which code belongs to which branch!
"""
</question>

<catsoop-section>Loops</catsoop-section>

<catsoop-subsection>`while` Loops</catsoop-subsection>

<question smallbox>
csq_prompt="""
Consider the following code:
```py
count = 0
while count <= 9:
    print(count)
```
How many times does `count` get printed? Enter "infinite" if the `while` loop never exits.
"""

csq_soln = "infinite"

csq_explanation = """
`count` is printed while it is less than or equal to `9`.
The value of `count` isn't updated within the loop so it is always `0`.
Therefore, this `while` loop will loop infinitely.
"""
</question>

<question smallbox>
csq_prompt="""
Consider the following code:
```py
count = 0
while count <= 9:
    print(count)
    count = count + 2
```
How many times does `count` get printed? Enter "infinite" if the `while` loop never exits.
"""

csq_soln = "5"

csq_explanation = """
`count` is printed while it is less than or equal to `9`.
It starts at `0` and increases by 2 every loop.
The values of count are: `0`, `2`, `4`, `6`, `8`, `10`.
When `count` is `10`, the `while` loop exits, so `count` is printed `5` times.
"""
</question>

<question smallbox>
csq_prompt="""
Consider the following code:
```py
count = 0
while count >= 0:
    if count**2 == 16:
        break
    print(count)
    count = count + 1
```
How many times does `count` get printed? Enter "infinite" if the `while` loop never exits.
"""

csq_soln = "4"

csq_explanation = """
The `while` loop continues as long as `count` is greater than or equal to `0`.
`count` starts at `0` and increases by 1 every loop, so it may appear to loop infinitely at first glance.
However, we have a `break` condition in the loop, which happens if `count**2 == 16`.
Remember, a `break` statement exits whatever loop it is in (`while` or `for` loop).
The values of count are: `0`, `1`, `2`, `3`, and `4`.
When `count` is `4`, the `break` condition is reached since `4^2 = 16`.
Notice that the `print` statement is after the `break` condition, so `count=4` is not printed here.
Therefore, `count` is printed 4 times (when it is `0`, `1`, `2`, and `3`).
"""
</question>

<catsoop-subsection>`for` Loops</catsoop-subsection>

<question smallbox>
csq_prompt="""
Consider the following code:
```py
my_letters = "qpoasfdeny"
fav_vowels = "eio"
vowel_count = 0
for letter in my_letters:
    if letter in fav_vowels:
        vowel_count = vowel_count + 1
```
What is the value of `vowel_count` after the `for` loop is done iterating?
"""

csq_soln = "2"

csq_explanation = """
`vowel_count` is incremented every time a `letter` in `my_letters` is also in `fav_vowels`.
This happens when `letter` is `o` and `e`, so `vowel_count` is `2`.
"""
</question>

<question pythonic>
csq_prompt="""
Consider the following code:
```py
things = ["books", "red", "apples", "broccoli", "bikes"]
other_things = ["movies", "red", "bananas", "zucchini", "bikes"]
matches = []
for i in range(len(things)):
    matches.append(things[i] == other_things[i])
```
What is the value of `matches` after the loop is done iterating? Write it as a list of Python objects.
"""

csq_soln = [False, True, False, False, True]

csq_explanation = """
This loop iterates through the indices of `things` and stores the index in the variable `i`.
Since `things` and `other_things` are the same length, we can safely use `i` as the index of `other_things` as well.
We append `things[i] == other_things[i]` to `matches` which evaluates to `True` if they are equal and `False` if not.
"""
</question>

<question pythonic>
csq_prompt="""
Consider the following code:
```py
data = [1, 4, 6, 11, 13, 20, 17, 18, 18, 3]
processed_data = []
for i, val in enumerate(data):
    if i % 2 == 0:
        processed_data.append(val)
    else:
        processed_data.append(val*2)
```
What is the value of `processed_data` after the loop is done iterating? Write it as a list of Python objects.
"""

csq_soln = [1, 8, 6, 22, 13, 40, 17, 36, 18, 6]

csq_explanation = """
This loop iterates through the indices and items of `data` at the same time.
`i` tracks the index while `val` tracks the items.
At each iteration, we check if `i % 2 == 0` (if `i` is even), and if it is, we add it to `processed_data` as is.
Otherwise, we add `val*2` to `processed_data`.
"""
</question>

<catsoop-section>Functions</catsoop-section>

<question pythoncode>
csq_prompt = """
Write a function which takes in a list of positive numbers, `nums`, and returns the maximum value in the list.
Do not use any built-in functions or modules.

Note: `max` is a Python keyword so it's good practice to not use it as a variable name.
Use a different name instead.
"""

csq_initial = """
def get_max(nums):
    \"\"\"
    nums: a list of positive numbers
    \"\"\"
    # your code here
    return
"""

csq_soln = """
def get_max(nums):
    \"\"\"
    nums: a list of positive numbers
    \"\"\"
    max_val = 0
    for val in nums:
        if val > max_val:
            max_val = val
    return max_val
"""

csq_tests = [
    {'code': 'ans = get_max([1, 5, 10, 100, 20])'},
    {'code': 'ans = get_max([0, 1000.0, 5.1, 3000.3, 19.123])'},
]
</question>

<question pythoncode>
csq_prompt = """
Write a function which takes in a list of numbers, `nums`, and returns a new list containing each number squared if it's positive or cubed if it's negative.
Do not use any built-in functions or modules.
"""

csq_initial = """
def square_or_cube(nums):
    \"\"\"
    nums: a list of numbers
    \"\"\"
    # your code here
    return
"""

csq_soln = """
def square_or_cube(nums):
    \"\"\"
    nums: a list of numbers
    \"\"\"
    new_nums = []
    for val in nums:
        if val >= 0:
            new_nums.append(val**2)
        else:
            new_nums.append(val**3)
    return new_nums
"""

csq_tests = [
    {'code': 'ans = square_or_cube([1, -1, 4, -4, 11, -3])'},
    {'code': 'ans = square_or_cube([0, 5.3, -9, 10, -2.6])'},
]
</question>
